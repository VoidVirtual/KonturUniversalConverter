#include <catch2/catch.hpp>
#include "converter/Converter.h"
#include "converter/ConvertableParser.h"
#include "exception/Exception.h"
TEST_CASE("Parse quantities", "[ConvertableParser]")
{
    Converter converter(15);
    converter.addRule("A","B","1.0");
    converter.addRule("B","C","1.0");
    converter.addRule("D","E","1.0");
    auto parser = converter.createParser();
    SECTION("")
    SECTION("Not a fraction")
    {
        try{
            parser.createFraction("A / B / C");
            REQUIRE(false);
        }catch(FractionParseException&){
            REQUIRE(true);
        }
    }
    SECTION("Unit numenator")
    {
        try{
            parser.createFraction("1 / A");
            REQUIRE(true);
        }catch(FractionParseException&){
            REQUIRE(false);
        }
    }
    SECTION("Unit numenator & denumenator")
    {
        try{
            parser.createFraction("1 / 1");
            REQUIRE(true);
        }catch(FractionParseException&){
            REQUIRE(false);
        }catch(UnknownQuantityException&){
            REQUIRE(false);
        }
    }
    SECTION("Empty numenator")
    {
        try{
            parser.createFraction(" / A");
            REQUIRE(false);
        }catch(FractionParseException&){
            REQUIRE(false);
        }catch(UnknownQuantityException&){
            REQUIRE(true);
        }
    }
}
TEST_CASE("Create product equality", "[ConvertableParser]")
{
    VertexMap<std::string> vertexMap;
    vertexMap["A"] = 0;
    vertexMap["B"] = 0;
    vertexMap["C"] = 0;
    vertexMap["D"] = 0;
    ConvertableExpressionParser parser(vertexMap);
    SECTION("Simple fractions")
    {
        Fraction f1 = parser.createFraction("A / B");
        Fraction f2 = parser.createFraction("C / D");
        auto[left, right] = parser.createProductEquality(std::move(f1),std::move(f2));
        REQUIRE(left.getString()=="A * D");
        REQUIRE(right.getString()=="B * C");
    }
    SECTION("Empty right fraction")
    {
        Fraction f1 = parser.createFraction("A / B");
        Fraction f2 = parser.createFraction("");
        REQUIRE(f2.getString()=="1");
        auto[left, right] = parser.createProductEquality(std::move(f1),std::move(f2));
        REQUIRE(left.getString()=="A");
        REQUIRE(right.getString()=="B");
    }
}
